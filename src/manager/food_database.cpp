#include "food_database.h"
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <iomanip>
#include <regex>
#include <cctype>

/**
 * FoodDatabase getInstance Method
 * @return The singleton instance of FoodDatabase
 * This method implements the singleton pattern.
 */
FoodDatabase& FoodDatabase::getInstance() {
    static FoodDatabase instance;
    return instance;
}

/**
 * FoodDatabase Constructor
 * Initializes the database with default paths.
 */
FoodDatabase::FoodDatabase() 
    : defaultBasicFoodPath("data/basic_food.json"),
      defaultCompositeFoodPath("data/composite_food.json") {
}

/**
 * FoodDatabase Destructor
 */
FoodDatabase::~FoodDatabase() {
    try {
        saveToFiles();
    } catch (const std::exception& e) {
        std::cerr << "Error saving food database: " << e.what() << std::endl;
    }
}

/**
 * getFood Method
 * @param id The ID of the food to retrieve
 * @return A shared pointer to the Food object with the given ID, or nullptr if not found
 */
std::shared_ptr<Food> FoodDatabase::getFood(const std::string& id) const {
    auto it = foods.find(id);
    if (it != foods.end()) {
        return it->second;
    }
    return nullptr;
}

/**
 * getAllFoods Method
 * @return A vector of all Food objects in the database
 */
std::vector<std::shared_ptr<Food>> FoodDatabase::getAllFoods() const {
    std::vector<std::shared_ptr<Food>> result;
    for (const auto& [_, food] : foods) {
        result.push_back(food);
    }
    return result;
}

/**
 * searchFoods Method
 * @param keywords The keywords to search for
 * @param matchAll Whether all keywords must match (AND) or at least one (OR)
 * @return A vector of Food objects that match the search criteria
 */
std::vector<std::shared_ptr<Food>> FoodDatabase::searchFoods(const std::vector<std::string>& keywords, bool matchAll) const {
    std::vector<std::shared_ptr<Food>> result;
    
    for (const auto& [_, food] : foods) {
        const std::vector<std::string>& foodKeywords = food->getKeywords();
        
        bool matches = matchAll;
        for (const auto& keyword : keywords) {
            // Convert to lowercase for case-insensitive search
            std::string lowerKeyword = keyword;
            std::transform(lowerKeyword.begin(), lowerKeyword.end(), lowerKeyword.begin(), ::tolower);
            
            bool keywordFound = false;
            for (const auto& foodKeyword : foodKeywords) {
                std::string lowerFoodKeyword = foodKeyword;
                std::transform(lowerFoodKeyword.begin(), lowerFoodKeyword.end(), lowerFoodKeyword.begin(), ::tolower);
                
                if (lowerFoodKeyword.find(lowerKeyword) != std::string::npos) {
                    keywordFound = true;
                    break;
                }
            }
            
            if (matchAll && !keywordFound) {
                matches = false;
                break;
            } else if (!matchAll && keywordFound) {
                matches = true;
                break;
            }
        }
        
        if (matches || keywords.empty()) {
            result.push_back(food);
        }
    }
    
    return result;
}

/**
 * addBasicFood Method
 * @param id The ID of the new food
 * @param keywords The keywords for searching
 * @param calories The calories per serving
 */
void FoodDatabase::addBasicFood(const std::string& id, const std::vector<std::string>& keywords, float calories) {
    if (foods.find(id) != foods.end()) {
        throw std::invalid_argument("Food with ID '" + id + "' already exists");
    }
    foods[id] = std::make_shared<BasicFood>(id, keywords, calories);
}

/**
 * addBasicFood Method (Autogenerated ID version)
 * @param keywords The keywords for searching
 * @param calories The calories per serving
 * @return The generated ID for the new food
 */
std::string FoodDatabase::addBasicFood(const std::vector<std::string>& keywords, float calories) {
    if (keywords.empty()) {
        throw std::invalid_argument("At least one keyword must be provided");
    }
    
    // Use the first keyword as the base for ID generation
    std::string id = generateFoodId(keywords[0]);
    
    // Call the original method with the generated ID
    addBasicFood(id, keywords, calories);
    
    return id;
}

/**
 * createCompositeFood Method
 * @param id The ID of the new composite food
 * @param keywords The keywords for searching
 * @param components A map of food IDs to servings
 */
void FoodDatabase::createCompositeFood(const std::string& id, const std::vector<std::string>& keywords, 
                                      const std::map<std::string, float>& components) {
    if (foods.find(id) != foods.end()) {
        throw std::invalid_argument("Food with ID '" + id + "' already exists");
    }
    
    // Check that all component foods exist
    for (const auto& [compId, _] : components) {
        if (foods.find(compId) == foods.end()) {
            throw std::invalid_argument("Component food '" + compId + "' does not exist");
        }
    }
    
    auto compositeFood = std::make_shared<CompositeFood>(id, keywords);
    
    // Add components and calculate total calories
    for (const auto& [compId, servings] : components) {
        compositeFood->addComponent(compId, servings);
    }
    
    float totalCalories = calculateCompositeFoodCalories(components);
    compositeFood->setTotalCalories(totalCalories);
    
    foods[id] = compositeFood;
}

/**
 * createCompositeFood Method (Autogenerated ID version)
 * @param keywords The keywords for searching
 * @param components A map of food IDs to servings
 * @return The generated ID for the new food
 */
std::string FoodDatabase::createCompositeFood(const std::vector<std::string>& keywords,
                                           const std::map<std::string, float>& components) {
    if (keywords.empty()) {
        throw std::invalid_argument("At least one keyword must be provided");
    }
    
    // Use the first keyword as the base for ID generation
    std::string id = generateFoodId(keywords[0]);
    
    // Call the original method with the generated ID
    createCompositeFood(id, keywords, components);
    
    return id;
}

/**
 * generateFoodId Method
 * @param baseKeyword The base keyword to use for ID generation
 * @return A unique ID based on the keyword
 */
std::string FoodDatabase::generateFoodId(const std::string& baseKeyword) {
    // Sanitize the base keyword to get a clean ID
    std::string baseId = sanitizeForId(baseKeyword);
    
    // If the base ID is empty after sanitization, use a default
    if (baseId.empty()) {
        baseId = "food";
    }
    
    // Check if the base ID is already unique
    if (isIdUnique(baseId)) {
        return baseId;
    }
    
    // If not unique, append a number until we find a unique ID
    int counter = 1;
    std::string uniqueId;
    
    do {
        uniqueId = baseId + std::to_string(counter);
        counter++;
    } while (!isIdUnique(uniqueId));
    
    return uniqueId;
}

/**
 * sanitizeForId Method
 * @param input The string to sanitize
 * @return A sanitized string suitable for an ID
 */
std::string FoodDatabase::sanitizeForId(const std::string& input) {
    std::string result;
    
    // Convert to lowercase
    for (char c : input) {
        if (std::isalnum(c)) {
            result += std::tolower(c);
        } else if (c == ' ' || c == '-' || c == '_') {
            // Replace spaces, hyphens, and underscores with underscores
            result += '_';
        }
        // Ignore other non-alphanumeric characters
    }
    
    // Replace multiple consecutive underscores with a single one
    result = std::regex_replace(result, std::regex("_+"), "_");
    
    // Remove leading and trailing underscores
    if (!result.empty() && result.front() == '_') {
        result.erase(0, 1);
    }
    if (!result.empty() && result.back() == '_') {
        result.pop_back();
    }
    
    return result;
}

/**
 * isIdUnique Method
 * @param id The ID to check
 * @return True if the ID is unique, false otherwise
 */
bool FoodDatabase::isIdUnique(const std::string& id) const {
    return foods.find(id) == foods.end();
}

/**
 * calculateCompositeFoodCalories Method
 * @param components A map of food IDs to servings
 * @return The total calories for the composite food
 */
float FoodDatabase::calculateCompositeFoodCalories(const std::map<std::string, float>& components) {
    float totalCalories = 0.0f;
    
    for (const auto& [compId, servings] : components) {
        auto compFood = getFood(compId);
        if (compFood) {
            totalCalories += compFood->getCaloriesPerServing() * servings;
        }
    }
    
    return totalCalories;
}

/**
 * saveToFiles Method
 * @param basicFoodPath The path to save basic foods to (uses default if empty)
 * @param compositeFoodPath The path to save composite foods to (uses default if empty)
 */
void FoodDatabase::saveToFiles(const std::string& basicFoodPath, const std::string& compositeFoodPath) {
    std::string bPath = basicFoodPath.empty() ? defaultBasicFoodPath : basicFoodPath;
    std::string cPath = compositeFoodPath.empty() ? defaultCompositeFoodPath : compositeFoodPath;
    
    try {
        // Save basic foods
        std::ofstream bFile(bPath);
        if (!bFile.is_open()) {
            throw std::runtime_error("Failed to open file for writing: " + bPath);
        }
        
        json basicFoodsJson = json::array();
        for (const auto& [_, food] : foods) {
            if (!food->isComposite()) {
                basicFoodsJson.push_back(basicFoodToJson(dynamic_cast<const BasicFood*>(food.get())));
            }
        }
        bFile << std::setw(4) << basicFoodsJson << std::endl;
        bFile.close();
        
        // Save composite foods
        std::ofstream cFile(cPath);
        if (!cFile.is_open()) {
            throw std::runtime_error("Failed to open file for writing: " + cPath);
        }
        
        json compositeFoodsJson = json::array();
        for (const auto& [_, food] : foods) {
            if (food->isComposite()) {
                compositeFoodsJson.push_back(compositeFoodToJson(dynamic_cast<const CompositeFood*>(food.get())));
            }
        }
        cFile << std::setw(4) << compositeFoodsJson << std::endl;
        cFile.close();
    } catch (const std::exception& e) {
        throw std::runtime_error("Error saving food database: " + std::string(e.what()));
    }
}

/**
 * loadFromFiles Method
 * @param basicFoodPath The path to load basic foods from (uses default if empty)
 * @param compositeFoodPath The path to load composite foods from (uses default if empty)
 */
void FoodDatabase::loadFromFiles(const std::string& basicFoodPath, const std::string& compositeFoodPath) {
    std::string bPath = basicFoodPath.empty() ? defaultBasicFoodPath : basicFoodPath;
    std::string cPath = compositeFoodPath.empty() ? defaultCompositeFoodPath : compositeFoodPath;
    
    foods.clear();
    
    try {
        // Load basic foods first
        std::ifstream bFile(bPath);
        if (bFile.is_open()) {
            json basicFoodsJson;
            bFile >> basicFoodsJson;
            bFile.close();
            
            if (basicFoodsJson.is_array()) {
                for (const auto& foodJson : basicFoodsJson) {
                    auto food = basicFoodFromJson(foodJson);
                    if (food) {
                        foods[food->getId()] = food;
                    }
                }
            }
        }
        
        // Then load composite foods (which might reference basic foods)
        std::ifstream cFile(cPath);
        if (cFile.is_open()) {
            json compositeFoodsJson;
            cFile >> compositeFoodsJson;
            cFile.close();
            
            if (compositeFoodsJson.is_array()) {
                for (const auto& foodJson : compositeFoodsJson) {
                    auto food = compositeFoodFromJson(foodJson);
                    if (food) {
                        foods[food->getId()] = food;
                    }
                }
            }
        }
    } catch (const std::exception& e) {
        throw std::runtime_error("Error loading food database: " + std::string(e.what()));
    }
}

/**
 * registerFoodDataSource Method
 * @param sourceName The name of the data source
 * @param dataFunction The function to call to get food data from this source
 */
void FoodDatabase::registerFoodDataSource(const std::string& sourceName, 
                                        std::function<std::vector<std::shared_ptr<BasicFood>>(const std::string&)> dataFunction) {
    foodDataSources[sourceName] = dataFunction;
}

/**
 * importFromSource Method
 * @param sourceName The name of the data source to import from
 * @param query The query to pass to the data source function
 * @return A vector of BasicFood objects imported from the source
 */
std::vector<std::shared_ptr<BasicFood>> FoodDatabase::importFromSource(const std::string& sourceName, const std::string& query) {
    auto it = foodDataSources.find(sourceName);
    if (it == foodDataSources.end()) {
        throw std::invalid_argument("Unknown food data source: " + sourceName);
    }
    
    auto importedFoods = it->second(query);
    
    // Add imported foods to the database
    for (const auto& food : importedFoods) {
        if (foods.find(food->getId()) == foods.end()) {
            foods[food->getId()] = food;
        }
    }
    
    return importedFoods;
}

/**
 * basicFoodToJson Method
 * @param food The BasicFood to convert to JSON
 * @return A JSON object representing the BasicFood
 */
json FoodDatabase::basicFoodToJson(const BasicFood* food) const {
    json j;
    j["id"] = food->getId();
    j["keywords"] = food->getKeywords();
    j["calories"] = food->getCaloriesPerServing();
    return j;
}

/**
 * compositeFoodToJson Method
 * @param food The CompositeFood to convert to JSON
 * @return A JSON object representing the CompositeFood
 */
json FoodDatabase::compositeFoodToJson(const CompositeFood* food) const {
    json j;
    j["id"] = food->getId();
    j["keywords"] = food->getKeywords();
    j["components"] = food->getComponents();
    j["calories"] = food->getCaloriesPerServing();
    return j;
}

/**
 * basicFoodFromJson Method
 * @param j The JSON to convert to a BasicFood
 * @return A shared pointer to a new BasicFood object
 */
std::shared_ptr<BasicFood> FoodDatabase::basicFoodFromJson(const json& j) const {
    std::string id = j["id"];
    std::vector<std::string> keywords = j["keywords"];
    float calories = j["calories"];
    
    return std::make_shared<BasicFood>(id, keywords, calories);
}

/**
 * compositeFoodFromJson Method
 * @param j The JSON to convert to a CompositeFood
 * @return A shared pointer to a new CompositeFood object
 */
std::shared_ptr<CompositeFood> FoodDatabase::compositeFoodFromJson(const json& j) const {
    std::string id = j["id"];
    std::vector<std::string> keywords = j["keywords"];
    std::map<std::string, float> components = j["components"];
    float calories = j["calories"];
    
    auto food = std::make_shared<CompositeFood>(id, keywords);
    
    for (const auto& [compId, servings] : components) {
        food->addComponent(compId, servings);
    }
    
    food->setTotalCalories(calories);
    
    return food;
}
